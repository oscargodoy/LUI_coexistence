---
title: 'Workflow: LUI and species coexistence'
author: "Rodrigo R. Granjel"
date: "`r format(Sys.time(), '%d/%m/%Y')`"
output:
  html_document:
    number_sections: yes
    toc: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(cache = TRUE)
```

# Prepare the data

First of all, we need to re-structure the database. We will only use data from 2008 to 2015. For this period, we select the 26 most common plant species. The reason why we select a 26 species community is because, at this moment, it is impossible to compute the analyses for a richer community (e.g. 50 species) due to computation limitations. To give an example, computing all posible combinations of 11 species in a 50 species community would take ca. `r round(0.003101254 * choose(50, 11) / 60 / 24 / 365)` years, while computing this for a 26 species community takes ca. `r round(0.003101254 * (choose(26, 11)) / 60 / 24)` days (there are ca. `r round(choose(50, 11) / choose(26, 11))` times more possible combinations for the 50 species community).

What it is important to notice, though, is that we will reduce the community to 26 for computing the structural coexistence outputs (i.e., after obtaining the inter- and intra-specific interaction coefficients). Why? Because the proper approach in a community with so many species as ours is to obtian the coefficients with the maximum number os species possible (we will use 50) and, then, reduce to the desired species number. That's the path we are going to follow here.

## Land Use Intensity (LUI)

First of all, we define the path to load the raw data and the number of plants we will use:

```{r path_and_plants}
#in the end, raw data needs to go to a public repository
raw_path <- "data/raw_data"

#number of plants in the community
n_plants <- 50
```

And then we start by the LUI dataset. We remove the undesired years: 2006 and 2007. Then, we re-structure it.

```{r restructure_lui}
#load LUI data
lui <- read.csv(paste(raw_path, "LUI06_15.csv", sep = "/"), header  = TRUE)

#select only the site AEG
lui$Plot <- substring(lui$Plot, 1, 3)
lui <- subset(lui, Plot == "AEG")

#stick with LUI at different years
lui.only <- lui[, grep("LUI", names(lui))]
lui.only2 <- lui.only[, -c(1:2)] ## remove 2006 and 2007
lui_tot <- cbind("plot" = lui$Plot, lui.only2)

#save lui_tot
write.table(lui_tot, "data/lui_tot.txt", row.names = FALSE, sep = "\t")

#restructure LUI
lu <- c(lui_tot$LUI_08, lui_tot$LUI_09, lui_tot$LUI_10, lui_tot$LUI_11,
        lui_tot$LUI_12, lui_tot$LUI_13, lui_tot$LUI_14, lui_tot$LUI_15)
yy <- c(rep(2008, nrow(lui_tot)), rep(2009, nrow(lui_tot)),
        rep(2010, nrow(lui_tot)), rep(2011, nrow(lui_tot)),
        rep(2012, nrow(lui_tot)), rep(2013, nrow(lui_tot)),
        rep(2014, nrow(lui_tot)), rep(2015, nrow(lui_tot)))
pp <- rep(lui_tot$plot, length(unique(yy)))

#create a re-structured LUI dataset
lui_total <- data.frame("Plot" = pp, "Year" = yy, "LUI" = lu)

#clean
rm(lui, lui_tot, lui.only, lui.only2, pp, lu, yy)
```

## Plant species data

### Prepare quantitative data

And continue with the plants dataset:

In this case, though, we will save two different data files. The first one that we obtain corresponds to the original data for the 50 most common species in the different plots, with a final column representing the cumulative data for all other species present at each plot, which we will call `rest`. Note that we also re-scale the data to avoid having values over 100%. **We will use this to quantify the intra- and inter-specific interaction coefficients for all plant species.**

```{r restructure_plants_quanti}
#this chunk depends on chunk(s): restructure_lui

#load plant data
plants <- read.csv(paste(raw_path, "BE.plants08.16.csv", sep = "/"), header = TRUE)

#remove data from 2016 because there is no LUI data
plants <- plants[plants$Year != 2016, ]

#remove info columns
#format is the same order as LUI, so we'll later merge with LUI to have all info
plant_only <- plants[-c(1:4)]

### top --- select the most common plant species
top <- rev(sort(apply(plant_only, 2, mean, na.rm = TRUE)))[1:n_plants]

top.long <- c(
"Poa trivialis", "Poa pratensis", "Alopecurus pratensis",                
"Dactylis glomerata", "Trifolium repens", "Taraxacum officinale",
"Lolium perenne", "Arrhenatherum elatius", "Festuca rubra",
"Festuca pratensis", "Trisetum flavescens", "Elymus repens",
"Trifolium pratense", "Ranunculus repens", "Bromus erectus",
"Ranunculus acris", "Bromus hordeaceus", "Plantago lanceolata",
"Achillea millefolium", "Anthriscus sylvestris", "Heracleum sphondylium",
"Galium mollugo", "Holcus lanatus", "Helictotrichon pubescens",
"Carex hirta", "Brachypodium pinnatum", "Phalaris arundinacea",
"Anthoxanthum odoratum", "Veronica chamaedrys", "Festuca ovina",
"Rumex acetosa", "Deschampsia cespitosa", "Phleum pratense",
"Agrostis stolonifera", "Cynosurus cristatus", "Cirsium oleraceum",
"Crepis biennis", "Cerastium holosteoides", "Plantago media",
"Thymus pulegioides", "Urtica dioica", "Lolium multiflorum",
"Cirsium arvense", "Ranunculus bulbosus", "Trifolium dubium",
"Lotus corniculatus", "Carum carvi", "Leontodon hispidus",
"Vicia sepium", "Medicago lupulina")

#short standard names for the selected plants --- WARNING: CURRENTLY, A MANUAL STEP
top.short <- c("Poa_tri", "Poa_pra", "Alo_pra", "Dac_glo", "Tri_rep", "Tar_off",
               "Lol_per", "Arr_ela", "Fes_rub", "Fes_pra", "Tri_fla", "Ely_rep",
               "Tri_pra", "Ran_rep", "Bro_ere", "Ran_acr", "Bro_hor", "Pla_lan",
               "Ach_mil", "Ant_syl", "Her_sph", "Gal_mol", "Hol_lan", "Hel_pub",
               "Car_hir", "Bra_pin", "Pha_aru", "Ant_odo", "Ver_cha", "Fes_ovi",
               "Rum_ace", "Des_ces", "Phl_pra", "Agr_sto", "Cyn_cri", "Cir_ole",
               "Cre_bie", "Cer_hol", "Pla_med", "Thy_pul", "Urt_dio", "Lol_mul",
               "Cir_arv", "Ran_bul", "Tri_dub", "Lot_cor", "Car_car", "Leo_his",
               "Vic_sep", "Med_lup")

spp_table <- data.frame("Abbreviation" = top.short, "Species" = top.long)
write.csv(spp_table, "results/species_table.csv")

#sum all the other plant species per row
rest <- apply(plant_only[, -match(names(top), names(plant_only))], 1, sum, na.rm = TRUE)

#dataset with the most common plant species
plant_only <- plant_only[, match(names(top), names(plant_only))]

#give them standard short names
names(plant_only) <- top.short

#add a column with the sum of the non-selected plant species
q_plants <- cbind(plant_only, rest); rm(rest)

# to re-scale to no more than 100%
q_plants <- q_plants / apply(q_plants, 1, sum) #q_plants = quantitative plant data

#add plot, year & LUI information
q_plants <- cbind(plants[c(1:4)], q_plants)

#save q_plants
write.table(q_plants, "data/q_plants.txt", row.names = FALSE, sep = "\t")
```

### Prepare qualitative data (presence/absence)

The second one corresponds to the presence or absence of the 26 most common plant species. To do so, we change the value of each cell for a 1 (values over 0) or a 0 (values equal to zero) where corresponds. This will allow us to explore the relationship between species richness and LUI and also to select the feasible combinations for each richness level. (The following code uses the data frame `plants`, obtained in the previous code chunk.)

```{r restructure_plants_qualit}
#this chunk depends on chunk(s): restructure_lui, restructure_plants_quanti
plant_only <- plant_only[, c(1:26)]

#change to presence/absence data (0 or 1)
for (i in 1:nrow(plant_only)){
  for (j in 1:ncol(plant_only)){
    if(is.na(plant_only[i, j])){
      #do nothing
    } else {
      if (plant_only[i, j] > 0){
        plant_only[i, j] <- 1
      }
    }
  }
}

#add LUI info, only to subsequantly remove ALL NAs (both from Lui and plants)
p_plant <- cbind(lui_total, plant_only)

#remove NAs
p_plant <- na.omit(p_plant)

#save p_plant
write.table(p_plant, "data/p_plant.txt", row.names = TRUE, sep = "\t")

#leave only the plant columns again for further analysis (combos)
p_plant_only <- p_plant[, -c(1:3)]

#write p_plant_only
write.table(p_plant_only, "data/p_plant_only.txt", row.names = FALSE, sep = "\t")

#clean a bit
rm(plants, plant_only, p_plant_only, i, j)
```

# Data description for decision-making

## Range of LUI and relationship with species richness

Now, we want to do two things:

- Undestand the range of our natural variability in LUI.
- Describe the relationship between the LUI and species richness, both for a community with all the species in our data (full community) and our 26-species community.

To do so, we already have the LUI data in good shape (`lui_total`), so we start by preparing the dataset for the full plant community:

```{r lui_richness_full_comm}
#this chunk depends on chunk(s): restructure_lui

#load plant data
plants <- read.csv(paste(raw_path, "BE.plants08.16.csv", sep = "/"), header = TRUE)

#remove data from 2016
plants <- plants[plants$Year != 2016, ]

#remove info columns
#format is the same order as LUI, so we'll later merge with LUI to have all info
plants <- plants[-c(1:4)]

#change to presence/absence data (0 or 1)
for (i in 1:nrow(plants)){
  for (j in 1:ncol(plants)){
    if(is.na(plants[i, j])){
      #do nothing
    } else {
      if (plants[i, j] > 0){
        plants[i, j] <- 1
      }
    }
  }
}

#number of species per plot
rich_full <- apply(plants, 1, sum, na.rm = TRUE)

#merge lui and richness
richness_full_comm <- cbind(lui_total, rich_full)

#year as factor for plotting
richness_full_comm$Year <- as.factor(richness_full_comm$Year)

#save full community presence data
write.table(richness_full_comm, "data/richness_full_comm.txt",
            row.names = FALSE, sep = "\t")

#clean
rm(i, j, rich_full)
```

Then, we apply an equivalent procedure to obtain the richness by datapoint of our 26-species community:

```{r lui_richness_26spp_comm}
#this chunk depends on chunk(s): restructure_lui, lui_richness_full_comm
community <- 26 #species

#dataset with the most common plant species
plants <- plants[, match(names(top[1:community]), names(plants))]

#give them standard short names
names(plants) <- top.short[1:community]

#number of species per plot
rich_26spp <- apply(plants, 1, sum, na.rm = TRUE)

#merge lui and richness
richness_26spp_comm <- cbind(lui_total, rich_26spp)

#year as factor for plotting
richness_26spp_comm$Year <- as.factor(richness_26spp_comm$Year)

#save full community presence data
write.table(richness_26spp_comm, "data/richness_26spp_comm.txt",
            row.names = FALSE, sep = "\t")

#clean
rm(lui_total, plants, rich_26spp)
```

And, finally, with both data frames ready we can proceed to plot the data to describe the variability of LUI and the relationship between LUI and species richness for both the full and 26-species community.

```{r SupFig1, warning = FALSE, message = FALSE, fig.height = 7, fig.width = 7}
#this chunk depends on chunk(s): restructure_plants_quanti,
#restructure_lui, lui_richness_full_comm, lui_richness_26spp_comm

#load ggplot2
library(ggplot2)

#color-blind friendly colour palette - do not lose clean this, it's very useful
color.blind <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
                 "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

#boxplot of LUI through the years
box_lui <- ggplot(data = richness_full_comm, aes(x = Year, y = LUI)) +
  geom_boxplot(aes(fill = Year), alpha = 0.75) +
  theme(legend.position = "none") +
  geom_abline(intercept = 3, slope = 0, linetype = "dashed") +
  geom_abline(intercept = 0.5, slope = 0, linetype = "dashed") +
  scale_x_discrete(limits = rev(levels(richness_full_comm$Year))) +
  scale_y_continuous(limits = c(0, 4.5), breaks = seq(0, 4.5, by = 0.5)) +
  coord_flip() +
  scale_fill_manual(values = color.blind)

#plot of the relationship between LUI and richness in different years (full community)
lui_rich_full <- ggplot(data = richness_full_comm,
                        aes(x = LUI, y = rich_full, colour = Year)) +
  geom_point(alpha = 0.15) + geom_smooth(alpha = 0, size = 1.1) +
  scale_x_continuous(limits = c(0.5, 3), breaks = seq(0.5, 3, by = 0.5)) +
  scale_y_continuous(position = "left") + ylab("Richness (full community)") +
  theme(legend.position = "none") + scale_colour_manual(values = color.blind)

#plot of the relationship between LUI and richness in different years (26-species comm)
lui_rich_26spp <- ggplot(data = richness_26spp_comm,
                         aes(x = LUI, y = rich_26spp, colour = Year)) +
  geom_point(alpha = 0.15) + geom_smooth(alpha = 0, size = 1.1) +
  scale_x_continuous(limits = c(0.5, 3), breaks = seq(0.5, 3, by = 0.5)) +
  scale_y_continuous(position = "left") +
  ylab("Richness (26-species community)") +
  theme(legend.position = "none") +
  scale_colour_manual(values = color.blind)

#load the ggpubr library for charts (nicely combining plots)
library(ggpubr)

#change the size of the panel letters
size_text <- 12

#step one: combine the full community and 26-spp plots
both_lui_rich <- ggarrange(lui_rich_full, lui_rich_26spp,
                           nrow = 2, align = "hv",
                           labels = c("B", "C"),
                           font.label = list(size = size_text),
                           hjust = c(-0.9, -0.9),
                           vjust = c(1.5, 0.85))

#step two: combine all
lui_richness <- ggarrange(box_lui, both_lui_rich,
                          widths = c(3, 4),
                          labels = "A",
                          font.label = list(size = size_text),
                          hjust = -1.55)
print(lui_richness)

#save the figure as png (change output format as you please)
ggsave(plot = lui_richness, "figures/paper_figures/SupFig1.png",
       width = 7, height = 7, dpi = 320)

#clean everything
rm(list=ls()[! ls() %in% c("n_plants", "raw_path")])
```

In brief, **we observe that our LUI values concentrate between 0.5 and 3.0, so we will not analyse what happens beyond this range.**

## Feasible combinations for each richness level

Picking which combinations we are going to use to apply the structural coexistence framework is not trivial. Given that the structural coexistence framework is extremely computation-demanding, it is imperative to carefully select the interactions to compute and remove those that don't make sense, biologically speaking (e.g, combinations that are theoretically feasible but can't be found in nature: our data).

### Select the richness levels for the analyses

First of all, we ought to understand how well represented are the different combinations of different richness levels in our data. This way, we avoid choosing a richness level that has actually no representation in nature.

```{r SupFig2, fig.height = 4, fig.width = 6}
#this chunk depends on chunk(s): path_and_plants
library(ggplot2)

#load qualitative plants only
p_plant_only <- read.table("data/p_plant_only.txt", header = TRUE, sep = "\t")

#calculate the percentage of presence of different richness values in the data
max_comb <- NULL
rich <- NULL
for (i in 2:25){
  rich <- c(rich, i)
  max_comb <- c(max_comb,
                length(which(apply(p_plant_only, 1, sum) > i))
                / nrow(p_plant_only) * 100)
}

#save as dataframe for plotting
saturation <- data.frame("richness" = rich, "ratio" = max_comb)

#plot `saturation`
(ratio_combos <- ggplot(data = saturation, aes(x = richness, y = ratio)) +
    scale_x_continuous(breaks = c(2, 3, 5, 7, 11, 17, 25)) +
    ggtitle("Community of 26 species") +
    xlab("Combinations' species richness") +
    ylab("Presence in the data (%)") +
    geom_line(size = 1.2, color = "grey") +
    geom_point(size = 2, color = "darkgreen"))

#save the plot
ggsave(plot = ratio_combos, filename = "figures/paper_figures/SupFig2.png",
       width = 6, height = 4, dpi = 320)

#clean (except for p_plant_only, that we'll use below)
rm(i, max_comb, rich, ratio_combos, saturation)
```

As can be observed, **the plot above urges us to select combinations that do not involve more than 17 plant species.**

### Pick the combinations for each richness level

Now, we need to select the specific combinations that are feasible (i.e., the ones that are actually present in our data). To do so, we have created a function called `selector` that, given a data frame ---with only plants in columns--- and a richness value (ranging from 2 to `ncol(df) - 1`), provides us with a data frame of combinations above a certain `threshold` of presence of that given combination in the data. For instance, if our data has 10 entries and a certain combination of species is present in 2 spots, that combinations will be selected by the function if we set a threshold below 20%.

The function looks as follows:

```{r function_selector}
#function to select the combinations above a certain threshold of presence
selector <- function(df, n, threshold){
  
  #vector with the names of all the species
  vec <- colnames(df)
  
  #define a vector with the maximum values different elements can reach
  maxim <- vec[(length(vec) - (n - 1)):length(vec)]
  
  #data frame to save the selected combinations
  sel_comb <- data.frame()
  
  #vector to save the combination to look for at each moment
  combo <- vec[1:n]
  
  #counter of times the combo is present
  counter <- 0
  
  #starting with the first combo
  for (w in 1:nrow(df)){
    
    #if all the species of the combo are present at a given spot
    if(isFALSE(0 %in% (df[w, which((vec %in% combo) == TRUE)]))){
      counter <- counter + 1 #add one to te counter
    }
  }
  
  #if the presence overcomes a certain threshold, in %, the combos is saved
  if ((counter / w * 100) > threshold){
    sel_comb <- rbind(sel_comb, cbind(t(combo), (counter / w * 100)))
  }
  
  
  #loop i starting at row two for all the rows
  i = 2 #define the starting point
  while (i != choose(length(vec), n)){
    
    #loop j for the elements of the combo vector, starting at position 2
    for (j in 1:n){
      
      #conditions to match
      if (combo[j] != maxim[j]){ #while the value is not the maximum
        
        if (j != n){ #if the position is not the last one yet
          #do nothing, continue to the next element
          
        } else { #if the element is, in fact, the last one
          combo[j] <- vec[which(combo[j] == vec) + 1] #write the following corresp. value
        }
      
      } else { #if it is actually the maximum value for that element
        #write the following corresponding values from the previous position to the end
        combo[(j - 1):n] <- vec[(which(combo[j - 1] == vec) + 1):
                                  ((which(combo[j - 1] == vec) + 1) + ((n - j) + 1))]
        break #enough - changes have been made
      }
    } #end j
    
    #counter of times the combo is present
    counter <- 0
    
    #continuing with all the other combos
    for (w in 1:nrow(df)){
      
      #if all the species of the combo are present at a given spot
      if(isFALSE(0 %in%(df[w, which((vec %in% combo) == TRUE)]))){
        counter <- counter + 1 #add one to te counter
      }
    }
    
    #if the presence overcomes a certain threshold, in %, the combos is saved
    if ((counter / w * 100) > threshold){
      sel_comb <- rbind(sel_comb, cbind(t(combo), (counter / w * 100)))
    }
    
    #next step
    i <- i + 1
    
  } #end i while
  return(sel_comb) #return the final df with all saved combinations
} #end selector()
```

And then we need to compute the function for different richness levels. This is an important step. Given that we may choose richness levels from 2 to 17, **we have decided to use the following sequence: 2, 3, 5, 7, 11 and 17 species**. In this sequence, each element is the result of the sum of the two previous elements minus one (e.g., `11 = (5 + 7) - 1`). Besides, the following piece of code should be run in a cluster of computation because it takes a long time to finish ---that's why the code is commented (annuled by `#`). In any case, note that we use the `p_plant_only` dataset and a threshold value of zero (if the combination is present at any given spot, we save it).

```{r combos_selection}
#this chunk depends on chunk(s): saturation, function_selector

#set a threshold (in %)
#t <- 0

#compute and save the selected combos (TO DO IN THE CLUSTER OF COMPUTATION!)
#combos2 <- selector(p_plant_only, n = 2, threshold = t)
#write.table(combos2, "results/selected_combos/combos2.txt", row.names = FALSE, sep = "\t")
#
#combos3 <- selector(p_plant_only, n = 3, threshold = t)
#write.table(combos3, "results/selected_combos/combos3.txt", row.names = FALSE, sep = "\t")
#
#combos5 <- selector(p_plant_only, n = 5, threshold = t)
#write.table(combos5, "results/selected_combos/combos5.txt", row.names = FALSE, sep = "\t")
#
#combos7 <- selector(p_plant_only, n = 7, threshold = t)
#combos11 <- selector(p_plant_only, n = 11, threshold = t)
#combos17 <- selector(p_plant_only, n = 17, threshold = t)

#clean a bit
rm(selector, p_plant_only)
```

# Quantify the interaction coefficients and LUI effects

## Average effects

At this point, we need to estimate the interaction coefficients and LUI effects. We want to obtain an interaction matrix between all **51 species** without the effects of LUI and with the effects of LUI, plus the intrinsic growth rate for all the species. **NOTE FOR MYSELF: I NEED TO ADD COMMENTARIES TO EXPLAIN THE STEPS IN THIS PIECE OF CODE!**

```{r quantify_coefficients, warning = FALSE, message = FALSE}
## IN ORDER TO ACCOUNT FOR TEMPORAL AUTOCORRELATION.
rm(list=ls())
library(reshape2)
library(nlme)
library(car)

plants <- read.csv("data/raw_data/BE.plants08.16.csv", header = TRUE)
plants <- plants[plants$Year != 2016, ] #remove data from 2016 because there is no LUI data

lui <- read.csv("data/raw_data/LUI06_15.csv", header = TRUE)

lui.only <- lui[, grep("LUI", names(lui))]
lui.only2 <- lui.only[, -c(1:2)] ## remove 2006 and 2007

plant.only <- plants[-c(1:4)]

### top50
top50 <- rev(sort(apply(plant.only, 2, mean, na.rm = TRUE)))[1:51]
top50.short <- c("Poa_tri", "Poa_pra", "Alo_pra", "Dac_glo", "Tri_rep", "Tar_sp",
                 "Lol_per", "Arr_ela", "Fes_rub", "Fes_pra", "Tri_fla", "Ely_rep",
                 "Tri_pra", "Ran_rep", "Bro_ere", "Ran_acr", "Bro_hor", "Pla_lan",
                 "Ach_mil", "Ant_syl", "Her_sph", "Gal_mol", "Hol_lan", "Hel_pub",
                 "Car_hir", "Bra_pin", "Pha_aru", "Ant_odo", "Ver_cha", "Fes_ovi",
                 "Rum_ace", "Des_ces", "Phl_pra", "Agr_sto", "Cyn_cri", "Cir_ole",
                 "Cre_bie", "Cer_hol", "Pla_med", "Thy_pul", "Urt_dio", "Lol_mul",
                 "Cir_arv", "Ran_bul", "Tri_dub", "Lot_cor", "Car_car", "Leo_his",
                 "Vic_sep", "Med_lup", "Pru_sp")

plants2 <- plants[,match(names(top50), names(plants))]

Rest <- apply(plant.only[, -match(names(top50), names(plant.only))], 1, sum,na.rm=T)

plants3 <- cbind(plants2, Rest)
plants3 <- plants3/apply(plants3, 1, sum) # to rscale to no more than 100%
names(plants3)[1:51] <- top50.short

pyear <- split(plants3, plants$Year)
pchange <- list()
pchange.logit <- list()
pchange.log <- list()
pchange.relative <- list()

# This is to prepare the database in order to conduct the analyses where t+1 will be compared to t
for(i in 1:(length(pyear)-1)){
  xx <- pyear[[i+1]]
  names(xx) <- paste(names(xx), "_delta",sep = "")
  xx2 <- cbind("LUI" = lui.only2[,i], xx)
  pchange[[i]] <- cbind(xx2, pyear[[i]])
}

pchange.all <- do.call("rbind", pchange)
Year_change <- paste(2008:2014, 2009:2015, sep="to")
pchange.all2 <- data.frame("Plot" = rep(unique(plants$Plot), 7),
                           "Site" = strtrim(unique(plants$Plot), 1),
                           "Year_change" = rep(Year_change, each = 150),
                           "Yeart" = rep(1:7, each = 150), pchange.all) 
yy <- names(pchange.all2)[grep("delta", names(pchange.all2))]

#Let's plot a couple of examples to see how the data looks like 
par(mfrow=c(2,2))
plot(pchange.all2$Poa_tri, pchange.all2$Poa_pra_delta, xlab="P. cover Poa_tri_year_t",
     ylab = "P. cover Poa_pra_yeart+1")
plot(pchange.all2$Poa_pra, pchange.all2$Poa_pra_delta, xlab="P. cover Poa_pra_year_t",
     ylab = "P. cover Poa_pra_yeart+1")
plot(pchange.all2$Alo_pra, pchange.all2$Alo_pra_delta, xlab="P. cover Alo_pra_year_t",
     ylab = "P. cover Alo_pra_yeart+1")
plot(pchange.all2$Dac_glo, pchange.all2$Dac_glo_delta, xlab="P. cover Dac_glo_year_t",
     ylab = "P. cover Dac_glo_yeart+1")

#perform the modelling with lme and temporal autocorrelation

lCtr <- lmeControl(maxIter = 500, msMaxIter = 500, tolerance = 1e-6, niterEM = 250, msMaxEval = 200)

##running all the models for the 51 sps. Site does not improve the model, so I have removed it. 
## I haven't also included weight factors because does not either improve the model. 
mlist <- list()
for(i in 1:51){
  mlist[[i]] <- lme(as.formula(paste(yy[i], " ~ LUI*(", paste(top50.short, collapse= "+"), ")")), data = pchange.all2, 
                random = ~1|Plot/Site, control = lCtr, correlation=corAR1(form = ~Yeart), method = 'REML', na.action = na.omit)
}

coef.list <- lapply(mlist, function(x)summary(x)$coef$fixed)

#the miscelaneous species "REST" is not saved
inter.mat <- matrix(nrow=length(yy) - 1, ncol=length(yy) - 1) #matrix of species interactions
lui.mat <- matrix(nrow=length(yy) - 1, ncol=length(yy) - 1) #matrix of how LUI modify pairwise interactions
intrinsic.site.lui <- matrix(nrow=length(yy) - 1, ncol = 2) #matrix of intrinsic ability to growth and how LUI modifies it

for(i in 1:length(coef.list)){

  cc <- coef.list[[i]] ## extract coefficients

  cc2 <- cc[-c(1:2)]
  cc3 <- cc2[c(1:51)]
  cc4 <- cc2[52:102]
  cc5 <- cc[1:2]

  inter.mat[i,] <- cc3
  lui.mat[i,] <- cc4
  intrinsic.site.lui[i,]<- cc5
}

yy2 <- gsub("_delta", "", yy)
yy2 <- yy2[-c(52)] # to remove name "rest"
diag(inter.mat)<- diag(inter.mat) - 1 #because assuming that the 45 degrees slope means no change
row.names(inter.mat) <- yy2
colnames(inter.mat) <- yy2
row.names(lui.mat) <- yy2
colnames(lui.mat) <- yy2
row.names(intrinsic.site.lui) <- yy2
colnames(intrinsic.site.lui) <- c("Intrinsic", "LUI")

#check whether diagonal values of all species are negative, if not these species needs to be removed in further analyses
#of structural stability as the method does not handle facilitation effects for intraspecific effects
neg_diag <- names(which((diag(inter.mat) < 0) == TRUE))
#in three species this are the case but might change to more or less depending of the LUI's effect

#Save all these matrices and then go to the structural stability approach in another R file
write.table(inter.mat, "results/interaction_matrix_lme_average_51.txt", row.names = TRUE, sep = "\t")
write.table(lui.mat, "results/lui_matrix_lme_average_51.txt", row.names = TRUE, sep = "\t")
write.table(intrinsic.site.lui, "results/intrinsic_site_lui_average_lme_51.txt", row.names = TRUE, sep = "\t")

inter.mat26 <- inter.mat[1:26, 1:26]
lui.mat26 <- inter.mat[1:26, 1:26]
intrinsic.site.lui26 <- intrinsic.site.lui[1:26, ]

#Save all these matrices and then go to the structural stability approach in another R file
write.table(inter.mat26, "results/interaction_matrix_lme_average_26spp.txt", row.names = TRUE, sep = "\t")
write.table(lui.mat26, "results/lui_matrix_lme_average_26spp.txt", row.names = TRUE, sep = "\t")
write.table(intrinsic.site.lui26, "results/intrinsic_site_lui_average_lme_26spp.txt", row.names = TRUE, sep = "\t")

##alarm
#source("code/beep.R") #warning to know
```


```{r past_method}
##number of plants
#n_plants <- 26
#
##this chunk depends on chunk(s): path_and_plants
#library(reshape2)
#library(nlme)
#library(car)
#
##load plant data
#plants <- read.csv("data/raw_data/BE.plants08.16.csv", header = TRUE)
#
##load LUI data
#lui <- read.csv("data/raw_data/LUI06_15.csv", header  = TRUE)
#
##stick with LUI at different years
#lui.only <- lui[, grep("LUI", names(lui))]
#lui.only2 <- lui.only[, -c(1:2)] ## remove 2006 and 2007
#
##leave only plant species' columns
#plant.only <- plants[-c(1:4)]
#
#### top50 --- select the 51 most common plant species
#top <- rev(sort(apply(plant.only, 2, mean, na.rm = TRUE)))[1:n_plants]
#
#
#plants2 <- plants[, match(names(top), names(plants))] #dataset with the most common plant species
#
#Rest <- apply(plant.only[, -match(names(top), names(plant.only))],
#              1, sum, na.rm = TRUE) #sum all the other plant species per row
#
#plants3 <- cbind(plants2, Rest) #add a column with the sum of the non-selected plant species
#plants3 <- plants3 / apply(plants3, 1, sum) # to rscale to no more than 100%
#names(plants3)[1:n_plants] <- top.short #give them standard names
#  
#
#pyear <- split(plants3, plants$Year) #create a different dataset within a list for each year
#pchange <- list()
#pchange.logit <- list()
#pchange.log <- list()
#pchange.relative <- list()
#
#
## This is to prepare the database in order to conduct the analyses where t+1 will be compared to t
#for(i in 1:(length(pyear) - 1)){
#  xx <- pyear[[i + 1]]
#  names(xx) <- paste(names(xx), "_delta", sep = "")
#  xx2 <- cbind("LUI" = lui.only2[, i], xx)
#  pchange[[i]] <- cbind(xx2, pyear[[i]])
#}
#
#pchange.all <- do.call("rbind", pchange)
#Year_change <- paste(2008:2015, 2009:2016, sep = "to")
#pchange.all2 <- data.frame("Plot" = rep(unique(plants$Plot), 8),
#                           "Site" = strtrim(unique(plants$Plot), 1),
#                           "Year_change" = rep(Year_change, each = 150),
#                           "Yeart" = rep(1:8, each = 150), pchange.all)
#yy <- names(pchange.all2)[grep("delta", names(pchange.all2))]
#
##perform the modelling with lme and temporal autocorrelation
#lCtr <- lmeControl(maxIter = 500, msMaxIter = 500, tolerance = 1e-6, niterEM = 250, msMaxEval = 200)
#
###running all the models for the 51 sps. Site does not improve the model, so I have removed it
### I haven't included weight factors either because they don't improve the model
#mlist <- list()
#for(i in 1:n_plants){
#  mlist[[i]] <- lme(as.formula(paste(yy[i], " ~ LUI*(", paste(top.short, collapse = "+"),")")),
#                    data = pchange.all2, random = ~1|Plot/Site, control = lCtr,
#                    correlation = corAR1(form = ~Yeart), method = 'REML', na.action = na.omit)
#} #IT TAKES SOME TIME TO RUN
#
#( coef.list <- lapply(mlist, function(x)summary(x)$coef$fixed) )
#
##the miscelaneous species "REST" is not saved
#inter.mat <- matrix(nrow = length(yy) - 1, ncol = length(yy) - 1) #matrix of species interactions
#lui.mat <- matrix(nrow = length(yy) - 1, ncol = length(yy) - 1) #matrix of how LUI modify pairwise interactions
#intrinsic.site.lui <- matrix(nrow = length(yy) - 1, ncol = 2) #matrix of intrinsic ability to growth and how LUI modifies it
#
#for(i in 1:length(coef.list)){
#  cc <- coef.list[[i]] ## extract coefficients
#  
#  cc2 <- cc[-c(1:2)]
#  cc3 <- cc2[c(1:26)]
#  cc4 <- cc2[27:52]
#  cc5 <- cc[1:2]
#  
#  inter.mat[i,] <- cc3
#  lui.mat[i,] <- cc4
#  intrinsic.site.lui[i,] <- cc5
#}
#
#yy2 <- gsub("_delta", "", yy)
#yy2 <- yy2[-c(length(yy2))] # to remove name "rest"
#diag(inter.mat) <- diag(inter.mat) - 1 #assuming that the 45 degrees slope means no change
#row.names(inter.mat) <- yy2
#colnames(inter.mat) <- yy2
#row.names(lui.mat) <- yy2
#colnames(lui.mat) <- yy2
#row.names(intrinsic.site.lui) <- yy2
#colnames(intrinsic.site.lui) <- c("Intrinsic", "LUI")
#
##check whether diagonal values of all species are negative, if not these species needs to be removed in further analyses
##of structural stability as the method does not handle facilitation effects for intraspecific effects
#neg_diag <- names(which((diag(inter.mat) < 0) == TRUE))
##in three species this is the case but might change to more or less depending of the,, LUI's effect
#
##Save all these matrices and then go to the structural stability approach in another R file
#write.csv(inter.mat, "results/interaction_matrix_lme_average_26.csv")
#write.csv(lui.mat, "results/lui_matrix_lme_average_26.csv")
#write.csv(intrinsic.site.lui, "results/intrinsic_site_lui_average_lme_26.csv")
```

**The species "`r neg_diag`" has/have negative diagonal values (i.e. intraspecific effects).**

## Errors

**UNDONE UNTIL TALKING TO OSCAR.** Now, we obtain the errors from the linear model. **NOTE FOR MYSELF: I NEED TO ADD COMMENTARIES TO EXPLAIN THE STEPS IN THIS PIECE OF CODE!**

```{r errors lm}
#coef.list.error <- lapply(mlist, function(x)summary(x)$tTable[, 2]) #column two correspond to std error
#
##the miscelaneous species "REST" is not saved
#inter.mat.error <- matrix(nrow = length(yy) - 1, ncol = length(yy) - 1)
#lui.mat.error <- matrix(nrow = length(yy) - 1, ncol = length(yy) - 1)
#intrinsic.site.lui.error <- matrix(nrow = length(yy) - 1, ncol = 2)
#
#for(i in 1:length(coef.list.error)){
#  cc <- coef.list.error[[i]] ## extract coefficients
#  
#  cc2 <- cc[-c(1:2)]
#  cc3 <- cc2[c(1:26)]
#  cc4 <- cc2[27:52]
#  cc5 <- cc[1:2]
#  
#  inter.mat.error[i,] <- cc3
#  lui.mat.error[i,] <- cc4
#  intrinsic.site.lui.error[i,] <- cc5
#}
#
#row.names(inter.mat.error) <- yy2
#colnames(inter.mat.error) <- yy2
#row.names(lui.mat.error) <- yy2
#colnames(lui.mat.error) <- yy2
#row.names(intrinsic.site.lui.error) <- yy2
#colnames(intrinsic.site.lui.error) <- c("Intrinsic", "LUI")
#
#write.csv(inter.mat.error, "results/interaction_matrix_lme_std_error_26.csv")
#write.csv(lui.mat.error, "results/lui_matrix_lme_std_error_26.csv")
#write.csv(intrinsic.site.lui.error, "results/intrinsic_site_lui_std_error_lme_26.csv")
##From here we can calculate latter 95CI intervals multiplying by Â±1.96
```

# Calculate the structural niche and fitness differences

It is time to apply the structural stability framework. First, prepare the matrix and intrinsic with the effects from different values of LUI, and also removing the species with negative intrinsic and intra-specific coefficients.

```{r prepare lui}
rm(list = ls())

#load coefficients
alpha <- as.matrix(read.table("results/interaction_matrix_lme_average_26spp.txt", header = TRUE, sep = "\t"))
lui_modify_alpha <- as.matrix(read.table("results/lui_matrix_lme_average_26spp.txt", header = TRUE, sep = "\t"))
intrinsic <- as.matrix(read.table("results/intrinsic_site_lui_average_lme_26spp.txt", header = TRUE, sep = "\t"))

#species
top.short <- c("Poa_tri", "Poa_pra", "Alo_pra", "Dac_glo", "Tri_rep", "Tar_off",
               "Lol_per", "Arr_ela", "Fes_rub", "Fes_pra", "Tri_fla", "Ely_rep",
               "Tri_pra", "Ran_rep", "Bro_ere", "Ran_acr", "Bro_hor", "Pla_lan",
               "Ach_mil", "Ant_syl", "Her_sph", "Gal_mol", "Hol_lan", "Hel_pub",
               "Car_hir", "Bra_pin")

#lui intervals
lui <- seq(from = 0.5, to = 3, by = 0.25)

lui_intrinsic <- list()
lui_alpha <- list()
xx <- matrix(nrow = length(top.short), ncol = 2, NA)
colnames(xx) <- c("intrinsic", "lui_value")
row.names(xx) <- paste(top.short, sep = ",")

#to obtain all value of intrinsic abundance at different LUI values
for(i in 1:(length(lui))){
  for(j in 1:length(row.names(intrinsic))){
    xx[j, 1] <- intrinsic[j, 1] + intrinsic[j, 2] * lui[i]
    xx[j, 2] <- lui[i]
  }
  lui_intrinsic[[i]] <- xx
}

#to obtain species with positive intrinsic at each site
lui_intrinsic_positive <-  list()
zz <- list()
for(i in 1:(length(lui_intrinsic))){
  zz[[i]] <- row.names(subset(lui_intrinsic[[i]], lui_intrinsic[[i]][, 1] > 0))
  lui_intrinsic_positive[[i]] <- lui_intrinsic[[i]][which(rownames(lui_intrinsic[[i]]) %in% zz[[i]]), ]
}

#to obtain interaction matrices at different LUI values
#subset the interaction matrices at different LUIs to those species showing positive growth rates.
hh <- list()

for(i in 1:(length(lui))){
  lui_alpha[[i]] <- alpha + lui_modify_alpha * lui[i]
  lui_alpha[[i]] <- lui_alpha[[i]][which(rownames(lui_alpha[[i]]) %in%
                                           row.names(lui_intrinsic_positive[[i]])),
                                   which(colnames(lui_alpha[[i]]) %in%
                                           row.names(lui_intrinsic_positive[[i]]))]
  hh[[i]] <- row.names(subset(lui_alpha[[i]],
                              diag(as.matrix(lui_alpha[[i]])) < 0)) #we hold those with negative intra
  lui_alpha[[i]] <- lui_alpha[[i]][which(rownames(lui_alpha[[i]]) %in% hh[[i]]),
                                   which(colnames(lui_alpha[[i]]) %in% hh[[i]])]
}

#get back to the intrinsic and reduce the species list to those with negative intras
for(i in 1:(length(lui_intrinsic_positive))){
  lui_intrinsic_positive[[i]] <- lui_intrinsic_positive[[i]][which(rownames(lui_intrinsic_positive[[i]]) %in% rownames(lui_alpha[[i]])), ]
}

#remove everything except for matrix and intrinsic with LUI
rm(list=ls()[! ls() %in% c("lui_alpha", "lui_intrinsic_positive")])

#save image
save.image(file = "results/LUI_effects.RData")
```

Second, we need to restrict the combinations to the species present at each LUI value, after removing the negative intra-specific and intrinsic effects. **Note: this code is also very computing demanding, so we run it in the cluster of computation.**

```{r adapt combos}
#bring back the alphas and intrinsic!
load("results/LUI_effects.RData")

#load combos of 2 species
combos2 <- read.table("results/selected_combos/combos2.txt", sep = "\t", header = TRUE)
combos2 <- combos2[, 1:(ncol(combos2) - 1)] #remove last column

#load combos of 3 species
combos3 <- read.table("results/selected_combos/combos3.txt", sep = "\t", header = TRUE)
combos3 <- combos3[, 1:(ncol(combos3) - 1)] #remove last column

##load combos of 5 species
#combos5 <- read.table("results/selected_combos/combos5.txt", sep = "\t", header = TRUE)
#combos5 <- combos5[, 1:(ncol(combos5) - 1)] #remove last column
#
##load combos of 7 species
#combos7 <- read.table("results/selected_combos/combos7.txt", sep = "\t", header = TRUE)
#combos7 <- combos7[, 1:(ncol(combos7) - 1)] #remove last column
#
##load combos of 11 species
#combos11 <- read.table("results/selected_combos/combos11.txt", sep = "\t", header = TRUE)
#combos11 <- combos11[, 1:(ncol(combos11) - 1)] #remove last column
#
##load combos of 17 species
#combos17 <- read.table("results/selected_combos/combos17.txt", sep = "\t", header = TRUE)
#combos17 <- combos17[, 1:(ncol(combos17) - 1)] #remove last column

#save again for the cluster
save.image(file = "results/cluster_combos.RData")

#define new lists to save the combos
lui_combos2 <- list()
lui_combos3 <- list()
lui_combos5 <- list()
lui_combos7 <- list()
lui_combos11 <- list()
lui_combos17 <- list()

#loops to select all the combos based on species interactions under LUI effects

#combinations of 2 species
for (i in 1:length(lui_alpha)){
  dd <- data.frame()
  for (j in 1:nrow(combos2)){
    include <- TRUE
    for (k in 1:ncol(combos2)){
      if (combos2[j, k] %in% rownames(lui_alpha[[i]])){
        #keep include as TRUE
      } else {
        include <- FALSE
      }
    }
    if (isTRUE(include)){
      dd <- rbind(dd, combos2[j, ])
    }
  }
  lui_combos2[[i]] <- dd
}

saveRDS(lui_combos2, "results/selected_combos/combos2.rds")


#combinations of 3 species
for (i in 1:length(lui_alpha)){
  dd <- data.frame()
  for (j in 1:nrow(combos3)){
    include <- TRUE
    for (k in 1:ncol(combos3)){
      if (combos3[j, k] %in% rownames(lui_alpha[[i]])){
        #keep include as TRUE
      } else {
        include <- FALSE
      }
    }
    if (isTRUE(include)){
      dd <- rbind(dd, combos3[j, ])
    }
  }
  lui_combos3[[i]] <- dd
}

saveRDS(lui_combos3, "results/selected_combos/combos3.rds")


##combinations of 5 species
#for (i in 1:length(lui_alpha)){
#  dd <- data.frame()
#  for (j in 1:nrow(combos5)){
#    include <- TRUE
#    for (k in 1:ncol(combos5)){
#      if (combos5[j, k] %in% rownames(lui_alpha[[i]])){
#        #keep include as TRUE
#      } else {
#        include <- FALSE
#      }
#    }
#    if (isTRUE(include)){
#      dd <- rbind(dd, combos5[j, ])
#    }
#  }
#  lui_combos5[[i]] <- dd
#}
#
#saveRDS(lui_combos5, "results/selected_combos/combos5.rds")
#
#
#combinations of 7 species
#for (i in 1:length(lui_alpha)){
#  dd <- data.frame()
#  for (j in 1:nrow(combos7)){
#    include <- TRUE
#    for (k in 1:ncol(combos7)){
#      if (combos7[j, k] %in% rownames(lui_alpha[[i]])){
#        #keep include as TRUE
#      } else {
#        include <- FALSE
#      }
#    }
#    if (isTRUE(include)){
#      dd <- rbind(dd, combos7[j, ])
#    }
#  }
#  lui_combos7[[i]] <- dd
#}
#
#saveRDS(lui_combos7, "results/selected_combos/combos7.rds")
#
#
##combinations of 11 species
#for (i in 1:length(lui_alpha)){
#  dd <- data.frame()
#  for (j in 1:nrow(combos11)){
#    include <- TRUE
#    for (k in 1:ncol(combos11)){
#      if (combos11[j, k] %in% rownames(lui_alpha[[i]])){
#        #keep include as TRUE
#      } else {
#        include <- FALSE
#      }
#    }
#    if (isTRUE(include)){
#      dd <- rbind(dd, combos11[j, ])
#    }
#  }
#  lui_combos11[[i]] <- dd
#}
#
#saveRDS(lui_combos11, "results/selected_combos/combos11.rds")
#
#
##combinations of 17 species
#for (i in 1:length(lui_alpha)){
#  dd <- data.frame()
#  for (j in 1:nrow(combos17)){
#    include <- TRUE
#    for (k in 1:ncol(combos17)){
#      if (combos17[j, k] %in% rownames(lui_alpha[[i]])){
#        #keep include as TRUE
#      } else {
#        include <- FALSE
#      }
#    }
#    if (isTRUE(include)){
#      dd <- rbind(dd, combos17[j, ])
#    }
#  }
#  lui_combos17[[i]] <- dd
#}
#
#saveRDS(lui_combos17, "results/selected_combos/combos17.rds")

rm(list = ls())


#from cluster to the "real world"
load("results/selected_combos/LUI_combos.RData")

for (i in 1:length(lui_combos5)){
  rownames(lui_combos5[[i]]) <- NULL
  rownames(lui_combos7[[i]]) <- NULL
  rownames(lui_combos11[[i]]) <- NULL
  rownames(lui_combos17[[i]]) <- NULL
}

saveRDS(lui_combos5, "results/selected_combos/combos5.rds")
saveRDS(lui_combos7, "results/selected_combos/combos7.rds")
saveRDS(lui_combos11, "results/selected_combos/combos11.rds")
saveRDS(lui_combos17, "results/selected_combos/combos17.rds")
```

We, now, load the packages and define the different functions needed for calculating the structural coexistence outputs.

```{r toolbox structural stability, message = FALSE, warning = FALSE}
#R-code of "A structural approach for understanding multispecies coexistence" by:
#Serguei Saavedra, Rudolf P. Rohr, Jordi Bascompte, Oscar Godoy, Nathan J.B. Kraft,
#and Jonathan M. Levine
#published in: Ecological Monographs in 2017

### LOAD PACKAGES
library(mvtnorm)
library(foreach)
library(doParallel)
library(parallel)
library(MASS)
library(doSNOW)

#input parameters:
#alpha = competition strenght matrix 
#r = vector of intrinsic growth rates

#structural niche difference (output on a log scale)
Omega <- function(alpha){
  n <- nrow(alpha)
  Sigma <-solve(t(alpha) %*% alpha, tol = 1e-40)
  d <- pmvnorm(lower = rep(0,n), upper = rep(Inf,n), mean = rep(0,n), sigma = Sigma)
  out <- log10(d[1]) + n * log10(2)
  return(out) 
}

#vector defining the centroid of the feasibility domain
r_centroid <- function(alpha){
  n <- nrow(alpha)
  D <- diag(1/sqrt(diag(t(alpha)%*%alpha)))
  alpha_n <- alpha %*% D
  r_c <- rowSums(alpha_n) /n 
  r_c <- t(t(r_c))
  return(r_c)
}


#structural fitness difference (in degree)
theta <- function(alpha,r){
  r_c <- r_centroid(alpha)
  out <- acos(sum(r_c*r)/(sqrt(sum(r^2))*sqrt(sum(r_c^2))))*180/pi
  return(out)
}


#test if a system (alpha and r) is feasible (output 1 = feasible, 0 = not feasible)
test_feasibility <- function(alpha,r){
  out <- prod(solve(alpha,r)>0)
  return(out)
}


#test which pairs in a system (alpha and r) are feasible (output 1 = feasible, 0 = not feasible)
test_feasibility_pairs <- function(alpha,r){
  n <- length(r)
  c <- combn(n,2)
  nc <- dim(c)[2]
  f <- rep(NA,nc)
  for (i in 1:nc){
      f[i] <- prod(solve(alpha[c[,i],c[,i]],r[c[,i]])>0)
  }
  out <- list(pairs = c, feasibility = f)
  return(out)
}


#compute the feasiblity domain, the feasibility domain of all pairs, and their overlap (Nrand = number of randomization)
compute_overlap <- function(alpha,Nrand){
  
  n <- dim(alpha)[1]

  counter_f <- 0
  counter_overlap <- 0
  counter_all <- 0
    
  for (i in 1:Nrand){
    
    r_rand <- abs(rnorm(n))  
    r_rand <- r_rand/sqrt(sum(r_rand^2))
  
    f1 <- test_feasibility(alpha,r_rand)  
    f2 <- test_feasibility_pairs(alpha,r_rand)$feasibility  
    
    counter_f <- counter_f + f1
    counter_all <- counter_all + prod(f2)
    counter_overlap <- counter_overlap + f1*prod(f2)
    
  }
  
  Omega <- counter_f/Nrand
  Omega_all <- counter_all/Nrand
  overlap <- counter_overlap/Nrand
  
  out <- list(Omega = Omega, Omega_all = Omega_all, overlap = overlap)
  return(out)
  
}


#function to compute the structural coexistence given a certan set of combos
str_coex_combos <- function(alpha, intrinsic, combos){
  
  combos[[i]] <- as.matrix(combos[[i]])
  
  col_results  <- c("omega", "theta", "overlap", "differential", "feasibility", "feasibility_pair_to_all", "lui")
  
  results_combo <- matrix (nrow = nrow(combos[[i]]), ncol = length(col_results))
  row.names(results_combo) <- apply(combos[[i]], 1, paste, collapse=".") 
  colnames(results_combo) <- col_results
  
  for (j in 1:(nrow(combos[[i]]))){
    ll <- combos[[i]][j,]
    mm <- alpha[[i]][which(rownames(alpha[[i]]) %in% ll), which(colnames(alpha[[i]]) %in% ll)]
    mm <- -1 * mm #this is because intras has to be positive

    ii <- subset(intrinsic[[i]], rownames(intrinsic[[i]]) %in% ll)
    #this is niche differences
    results_combo[j, 1] <- 10^Omega(mm)
    #this is fitness differences
    results_combo[j, 2] <- theta(mm, ii[, 1])
    co <- compute_overlap(mm, 1000)
    #this is community overlap
    results_combo[j, 3] <- co$overlap
    #this is community differential
    results_combo[j, 4] <- co$Omega - co$Omega_all
    #this is whether all speceis can coexist
    results_combo[j, 5] <- test_feasibility(mm, ii[, 1]) 
    #this is whether pairs do not coexist but the multispecies assemblage does
    results_combo[j, 6] <- sum(test_feasibility_pairs(mm, ii[, 1])$feasibility) /
      length(test_feasibility_pairs(mm, ii[, 1])$feasibility)
    results_combo[j, 7] <- unique(intrinsic[[i]][, 2])
  }
  return(results_combo)
}


##function to know which plant species have negative intraspecific interaction coefficients
#intras <- function(alpha, combos){
#  
#  combos[[i]] <- as.matrix(combos[[i]])
#  neg_intras <- data.frame()
#  
#  for (j in 1:(nrow(combos[[i]]))){
#    ll <- combos[[i]][j,]
#    mm <- alpha[[i]][which(rownames(alpha[[i]]) %in% ll), which(colnames(alpha[[i]]) %in% ll)]
#    mm <- -1 * mm #this is because intras has to be positive
#    
#    #save info to locate the species in case of negative intras
#    if(length(names(which((diag(mm) > 0) == TRUE)) != 0)){
#      neg_intras <- rbind(neg_intras,
#                          data.frame("lui_level" = i,
#                                     "combo" = j,
#                                     "species" = paste(names(which((diag(mm) > 0) == TRUE)), collapse = " & ")))
#    }
#  }
#  return(neg_intras)
#}
```

And, finally, apply the structural stability approach to calculate the mechanisms of multispecies coexistence. We do it for 2 species because it takes around 10 minutes to run (with parallel computing and 4 cores). The other combinations, except for 17 species, need to be done using the cluster.

```{r structural stability}
#load the alpha and intrinsic
load(file = "results/LUI_effects.RData")

#load the combos
combos_lui2 <- readRDS("results/selected_combos/combos2.rds")
combos_lui3 <- readRDS("results/selected_combos/combos3.rds")

#parallel
cores = detectCores()
cl <- makeCluster(cores[1])
registerDoSNOW(cl) #defines parallel computation 
startime <- Sys.time() # to see how much it takes to run


#compute combinations of 2 species
results_coex <- list()
results_coex <- foreach (i = 1:length(combos_lui2), .packages = "mvtnorm") %dopar% {
  str_coex_combos(alpha = lui_alpha, intrinsic = lui_intrinsic_positive, combos = combos_lui2)
}

##re-structure results for 2 species
coex2 <- data.frame()
for(i in 1:length(results_coex)){
  a <- data.frame("combos" = rownames(results_coex[[i]]),
                                   "SND" = results_coex[[i]][, 1],
                                   "SFD" = results_coex[[i]][,2],
                                   "feasibility" = results_coex[[i]][, 5],
                                   "LUI" = results_coex[[i]][, 7])
  coex2 <- rbind(coex2, a)
}

write.csv(coex2, file = "results/results-LUI_coexistence-2spp.csv", row.names = FALSE)


#compute combinations of 3 species
results_coex <- list()
results_coex <- foreach (i = 1:length(combos_lui3), .packages = "mvtnorm") %dopar% {
  str_coex_combos(alpha = lui_alpha, intrinsic = lui_intrinsic_positive, combos = combos_lui3)
}

#specific changes to 3 species
##re-structure results for 2 species
coex3 <- data.frame()
for(i in 1:length(results_coex)){
  a <- data.frame("combos" = rownames(results_coex[[i]]),
                                   "SND" = results_coex[[i]][, 1],
                                   "SFD" = results_coex[[i]][,2],
                                   "overlap" = results_coex[[i]][, 3],
                                   "differential" = results_coex[[i]][, 4],
                                   "feasibility" = results_coex[[i]][, 5],
                                   "pair_to_all" = results_coex[[i]][, 6],
                                   "LUI" = results_coex[[i]][, 7])
  coex3 <- rbind(coex3, a)
}

write.csv(coex3, file = "results/results-LUI_coexistence-3spp.csv", row.names = FALSE)

#STOP cluster
stopCluster(cl) #stop cluster
endtime <- Sys.time() #save time once finished
(totime <- endtime - startime)

#alarm, in case it is needed
#source("code/beep.R")
```

# Figures analysing the results for 2 and 3 species

```{r 2spp fig, message = FALSE, warning = FALSE}
#load coexistence 2 species results
#coex2 <- read.table(file = "results/coex_LUI_2spp.txt", header = TRUE, sep = "\t")
coex2 <- read.csv(file = "results/results-LUI_coexistence-2spp.csv")
coex2$feasibility <- as.factor(coex2$feasibility)
#coex2$LUI <- as.factor(coex2$LUI)

coex3 <- read.csv(file = "results/results-LUI_coexistence-3spp.csv")
coex3$feasibility <- as.factor(coex3$feasibility)
#coex3$LUI <- as.factor(coex2$LUI)

#load ggplot2
library(ggplot2)

#some plots

#x = SND, y = SFD, color = feasibility
ggplot(data = coex2, aes(x = SND, y = SFD, color = feasibility)) +
  geom_point(alpha = 0.4, size = 1.5) +
  ggtitle("Combinations of 2 species")

ggplot(data = coex3, aes(x = SND, y = SFD, color = feasibility)) +
  geom_point(alpha = 0.4, size = 1.5) +
  ggtitle("Combinations of 3 species")

#x = LUI, y = SND
ggplot(data = coex2, aes(x = LUI, y = SND)) +
  geom_point(alpha = 0.5) +
  geom_smooth(alpha = 0, size = 2) +
  ggtitle("Combinations of 2 species")

ggplot(data = coex3, aes(x = LUI, y = SND)) +
  geom_point(alpha = 0.5) +
  geom_smooth(alpha = 0, size = 2) +
  ggtitle("Combinations of 3 species")

#x = LUI, y = SFD
ggplot(data = coex2, aes(x = LUI, y = SFD)) +
  geom_point(alpha = 0.5) +
  geom_smooth(alpha = 0, size = 2) +
  ggtitle("Combinations of 2 species")

ggplot(data = coex3, aes(x = LUI, y = SFD)) +
  geom_point(alpha = 0.5) +
  geom_smooth(alpha = 0, size = 2) +
  ggtitle("Combinations of 3 species")

#x = LUI, y = feasibility
ggplot(data = coex2, aes(x = LUI, y = as.integer(feasibility)-1)) +
  geom_point() +
  geom_smooth(alpha = 0, size = 2) +
  ylab("Feasibility") +
  ggtitle("Combinations of 2 species")

ggplot(data = coex3, aes(x = LUI, y = as.integer(feasibility)-1)) +
  geom_point() +
  geom_smooth(alpha = 0, size = 2) +
  ylab("Feasibility") +
  ggtitle("Combinations of 3 species")
```

**THIS IS JUST NOT POSSIBLE. THERE IS NO COEXISTENCE. SNDs ARE LOW AND SFDs TOO HIGH. THERE MUST BE AN ERROR SOMEWHERE BUT I AM UNABLE TO DETECT IT.**

# *Comprobations*

## *Relationship between Oscar's and Rodrigo's interaction matrix*

```{r rodroscar}
oscar <- read.csv("results/OG_results/interaction_matrix_lme_average_50.csv", row.names = 1)
rodrigo <- read.table("results/interaction_matrix_lme_average_26spp.txt", header = TRUE, sep = "\t")

kk <- c(which(names(oscar) %in% names(rodrigo))[1:5], 6, which(names(oscar) %in% names(rodrigo))[6:length(which(names(oscar) %in% names(rodrigo)))])

oscar <- oscar[kk, kk]

oscar <- oscar[order(names(oscar)), order(names(oscar))]
rodrigo <- rodrigo[order(names(rodrigo)), order(names(rodrigo))]

oscar <- as.vector(as.matrix(oscar))
rodrigo <- as.vector(as.matrix(rodrigo))

plot(rodrigo, oscar); abline(res <- lm(oscar ~ rodrigo))

RSS <- c(crossprod(res$residuals))
MSE <- RSS / length(res$residuals)
(RMSE <- sqrt(MSE))
```

## *Relationship between Will Petry's and Serguei Saavedra's SND*

```{r PetriSaavedra}
coex2 <- read.csv(file = "results/results-LUI_coexistence-2spp.csv")
coex3 <- read.csv(file = "results/results-LUI_coexistence-3spp.csv")

PS2 <- data.frame("Petri" = coex2$SND, "Saavedra" = exp(log10(coex2$SND)))
PS3 <- data.frame("Petri" = coex3$SND, "Saavedra" = exp(log10(coex3$SND)))

rm(coex2, coex3)

library(ggplot2)
library(ggpubr)

(plotPS2 <- ggplot(data = PS2, aes(Petri, y = Saavedra)) +
    geom_abline(slope = 1, color = "darkgreen") +
    geom_hline(yintercept = 1, lty = 5) +
    geom_vline(xintercept = 1, lty = 5) +
    geom_point(na.rm = TRUE, size = 2, shape = 1) +
    labs(title = "SND for combinations of 2 species",
         x = "Will Petry",
         y = "Serguei Saavedra") +
    theme_classic2())

(plotPS3 <- ggplot(data = PS3, aes(Petri, y = Saavedra)) +
    geom_abline(slope = 1, color = "darkgreen") +
    geom_hline(yintercept = 1, lty = 5) +
    geom_vline(xintercept = 1, lty = 5) +
    geom_point(na.rm = TRUE, size = 2, shape = 1) +
    labs(title = "SND for combinations of 3 species",
         x = "Will Petry",
         y = "Serguei Saavedra") +
    theme_classic2())
```

# Random

```{r create_random}
#load lui_alpha and intrinsic
load(file = "results/LUI_effects.RData")

### function to obtain random values
randomize <- function(coefs){
  v <- 0
  if ((range(coefs)[1] * range(coefs)[2]) < 0){
    for (i in 2:(length(coefs) - 1)){
      v <- c(v, runif(1, min = -sum(abs(range(coefs))) / length(coefs),
                      max = sum(abs(range(coefs))) / length(coefs)))
    }
  } else {
    if (min(coefs) < 0){
      for (i in 2:(length(coefs) - 1)){
        v <- c(v, runif(1, min = (min(coefs) - max(coefs)) / length(coefs),
                        max = -(min(coefs) - max(coefs)) / length(coefs)))
      }
    } else {
      for (i in 2:(length(coefs) - 1)){
        v <- c(v, runif(1, min = -(max(coefs) - min(coefs)) / length(coefs),
                        max = (max(coefs) - min(coefs)) / length(coefs)))
      }
    }
  }
  return(c(v, 0))
}

#loop for each LUI value
random_intrinsic <- list()
random_alpha <- list()

for (i in 1:length(lui_alpha)){
  
  #define intras, inters e intrinsic
  alpha <- lui_alpha[[i]]
  intras <- as.vector(diag(alpha));
  diag(alpha) <- NA; inters <- as.vector(alpha); inters <- inters[!is.na(inters)]
  intrinsic <- as.vector(lui_intrinsic_positive[[i]][, 1])
  lui <- as.vector(lui_intrinsic_positive[[i]][, 2])
  species_names <- as.vector(rownames(lui_intrinsic_positive[[i]]))
  
  #loop within each LUI level
  n <- 999 #number of random replicates
  rintrinsic <- list()
  ralpha <- list()
  
  for (j in 1:n){
    #output random intrinsic
    rintrinsic[[j]] <- as.matrix(data.frame(
      "intrinsic" = abs(sample(sort(intrinsic) + randomize(intrinsic))),
      "lui" = lui))
    rownames(rintrinsic[[i]]) <- species_names
    
    #define random
    random <- 1 - diag(length(intras))
    
    #fill random with inters
    random[random == 1] <- sample(sort(inters) + randomize(inters))
    
    #fill random with intras
    diag(random) <- sample(sort(intras) + randomize(intras))
    
    #row and column names
    rownames(random) <- rownames(alpha)
    colnames(random) <- colnames(alpha)
    
    #output random alphas
    ralpha[[j]] <- random
  }
  random_intrinsic[[i]] <- rintrinsic
  random_alpha[[i]] <- ralpha
}

#modify list intrinsic
r_intr <- random_intrinsic
random_intrinsic <- list()
time <- 0
for (i in 1:length(r_intr)){
  for (j in 1:length(r_intr[[i]])){
    time <- time + 1
    random_intrinsic[[time]] <- r_intr[[i]][[j]]
  }
}

#modify list alpha
r_alpha <- random_alpha
random_alpha <- list()
time <- 0
for (i in 1:length(r_alpha)){
  for (j in 1:length(r_alpha[[i]])){
    time <- time + 1
    random_alpha[[time]] <- r_alpha[[i]][[j]]
  }
}

#write RDS
saveRDS(random_intrinsic, "results/random/random_intrinsic.RDS")
saveRDS(random_alpha, "results/random/random_alpha.RDS")
```

```{r random_example, fig.width = 4, fig.height = 8}
#graphical example
library(ggpubr)
library(car)

ggarrange(ggdensity(intras,
                    main = "Observed",
                    xlab = ""),
          ggdensity(sample(sort(intras) + randomize(intras)),
                    main = "Randomised #1",
                    xlab = ""),
          ggdensity(sample(sort(intras) + randomize(intras)),
                    main = "Randomised #2",
                    xlab = ""),
          ggdensity(sample(sort(intras) + randomize(intras)),
                    main = "Randomised #3",
                    xlab = "Intra-specific coefficients"),
          ncol = 1, nrow = 4, align = "v")
```

```{r random_image_cluster}
#save image for random results in the cluster
intrinsic <- readRDS("results/random/random_intrinsic.RDS")
alpha <- readRDS("results/random/random_alpha.RDS")

#read combos for 2 and 3 species
combos_lui2 <- readRDS("results/selected_combos/combos2.rds")
combos_lui3 <- readRDS("results/selected_combos/combos3.rds")

#settings and loop
n <- 999
t <- 0
combos2 <- list()
combos3 <- list()
for(i in 1:length(combos_lui2)){
  for (j in 1:n){
    t <- t + 1
    combos2[[t]] <- combos_lui2[[i]]
    combos3[[t]] <- combos_lui3[[i]]
  }
}

#keep only desired elements
rm(list=ls()[! ls() %in% c("alpha", "intrinsic", "combos2", "combos3")])

#save as image for the cluster
save.image(file = "cluster/random_cluster.RData")

#clean
rm(list = ls())
```





